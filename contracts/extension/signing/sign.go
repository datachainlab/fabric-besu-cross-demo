package signing

import (
	"bytes"
	"crypto/ecdsa"
	"fmt"
	"github.com/btcsuite/btcd/btcec"
	"github.com/ethereum/go-ethereum/accounts"
	"github.com/gogo/protobuf/jsonpb"

	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	sdk "github.com/cosmos/cosmos-sdk/types"
	txtypes "github.com/cosmos/cosmos-sdk/types/tx"
	txsigning "github.com/cosmos/cosmos-sdk/types/tx/signing"
	"github.com/ethereum/go-ethereum/crypto"
)

// protoTxProvider is a type which can provide a proto transaction. It is a
// workaround to get access to the wrapper TxBuilder's method GetProtoTx().
type protoTxProvider interface {
	GetProtoTx() *txtypes.Tx
}

func Sign(tx sdk.Tx, privKey secp256k1.PrivKey) (*txsigning.SignatureV2, error) {
	bz, err := GetSignBytes(tx)
	if err != nil {
		return nil, err
	}
	priv, _ := btcec.PrivKeyFromBytes(btcec.S256(), privKey.Key)
	sig, err := crypto.Sign(GetHashMsg(bz), priv.ToECDSA())
	if err != nil {
		return nil, err
	}
	sig[64] += 27 // Transform V from 0/1 to 27/28 according to the yellow paper
	return &txsigning.SignatureV2{
		PubKey: privKey.PubKey(),
		Data: &txsigning.SingleSignatureData{
			Signature: sig,
		},
	}, nil
}

// TODO: Now signed data is marshalled for readbility but consider to change a well-known standards such as EIP-712.
var jm = &jsonpb.Marshaler{OrigName: true, EmitDefaults: true, AnyResolver: nil}

// VerifyEthSignature verifies that the signature was made by a specific Ethereum address
func VerifyEthSignature(tx sdk.Tx, address []byte, sig txsigning.SignatureV2) error {
	// get byteMsg used for signature from tx
	bz, err := GetSignBytes(tx)
	if err != nil {
		return err
	}

	// get signature data
	sigData, err := getSignatureData(&sig)
	if err != nil {
		return err
	}

	// check address between one in sig and one generated by pubkey coming from tx byteMsg and signature
	ethPubkey, err := GetEthereumPubkey(sigData, GetHashMsg(bz))
	if err != nil {
		return err
	}
	addr := crypto.PubkeyToAddress(*ethPubkey).Bytes()
	if !bytes.Equal(address, addr) {
		return fmt.Errorf("got unexpected signer address: expected=%X actual=%X", address, addr)
	}

	return nil
}

func GetSignBytes(tx sdk.Tx) ([]byte, error) {
	tp, ok := tx.(protoTxProvider)
	if !ok {
		return nil, fmt.Errorf("invalid tx type: %T", tx)
	}
	ptx := tp.GetProtoTx()
	ptx.AuthInfo.SignerInfos = nil
	ptx.Signatures = nil

	buf := new(bytes.Buffer)
	err := jm.Marshal(buf, ptx)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func getSignatureData(sig *txsigning.SignatureV2) ([]byte, error) {
	if sig.Data == nil {
		return nil, fmt.Errorf("signature data is nil")
	}
	data, ok := sig.Data.(*txsigning.SingleSignatureData)
	if !ok {
		return nil, fmt.Errorf("invalid signature data")
	}
	if len(data.Signature) == 0 {
		return nil, fmt.Errorf("signature data has no signature")
	}
	return data.Signature, nil
}

func GetHashMsg(byteMsg []byte) []byte {
	return accounts.TextHash(byteMsg)
}

func GetEthereumPubkey(sig []byte, hashMsg []byte) (*ecdsa.PublicKey, error) {
	byteSig, err := convertSignature(sig)
	if err != nil {
		return nil, err
	}
	return crypto.SigToPub(hashMsg, byteSig)
}

// sig must be 65 byte
func convertSignature(sig []byte) ([]byte, error) {
	sig[64] -= 27 // EIP-191: Transform V from 27/28 to 0/1 according to the yellow paper for verification.
	return sig, nil
}
